"""


"""

import os.path as op
import nibabel as nb
import argparse

import numpy as np
import pandas as pd
import math as m
from sklearn.linear_model import LinearRegression, Ridge
from sklearn.metrics import calinski_harabasz_score, davies_bouldin_score
from sklearn.preprocessing import normalize
from sklearn.cluster import AgglomerativeClustering, KMeans
from sklearn.mixture import BayesianGaussianMixture
from sklearn import manifold
from sklearn.linear_model import Ridge
from sklearn.preprocessing import PolynomialFeatures
from sklearn.pipeline import make_pipeline
from sklearn.metrics import r2_score
from scipy.cluster.hierarchy import dendrogram, linkage
from nilearn.image import resample_to_img, math_img
from nilearn.masking import apply_mask, unmask
from nilearn import plotting
from scipy.stats.mstats import spearmanr
from scipy.stats import f_oneway
from scipy.spatial.distance import squareform, euclidean

from warnings import warn
from tqdm import tqdm

import matplotlib.pyplot as plt
from matplotlib.ticker import IndexFormatter, FuncFormatter
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.animation import FuncAnimation
import seaborn as sns
sns.set(style="ticks")

from .utils import root_tri_num, tri_num
from .rdm import cross_vect_score, check_rdm


def nperms_indexes(nobj, nperm):
    """
    Generates permutations

    Perms contains the permutations of a square distance matrix
    of size nobj generated by permuting simultaneously the nobj columns and
    rows.
    Data is assumed to be of size [npair,ncol] where npair = nobj*(nobj-1)/2,
    and distances within each column are sorted as expected by squareform().

    Parameters
    ===========
    nobj: unsigned int
        Number of objects (= number of rows = number of cols) of the RDM.

    nperm: unsigned int
        Number of permutations

    Returns
    ========
    perms: npairs x nperms numpy array
        Permuted elements indexes

    Credits
    ========
    Inspired by Matlab script of:
    Bruno L. Giordano, February 2017
    Institute of Neuroscience and Psychology, University of Glasgow
    brungio@gmail.com

    """
    # tmpperms = list of index permutation
    r = np.random.randn(nperm, nobj)
    tmpperms = np.argsort(r)

    # Number of pair of elements (triangular number)
    npairs = tri_num(nobj - 1) 
    # Create a matrix with the index of each element
    idx = squareform(np.array(range(npairs)))

    # Initialize permutation
    perms = np.zeros((nperm, npairs), dtype=int)
    for wichperm in range(nperm):
        # Generate the correct perumutation (taking care columns and rows
        # dependencies)
        tmp = tmpperms[wichperm, :]
        iidx = idx[np.tile(tmp, nobj), np.repeat(tmp, nobj)].reshape(nobj, nobj)
        # Transform matrix into vector
        perms[wichperm, :] = squareform(iidx)

    return perms


def mantel_test(rdm_a, rdm_b, distance="euclidean", n_perms=1000, perms=None):
    """
        Mantel permutation test between two RDMs.

        Arguments
        =========
        rdm_a, rdm_b:

        modelname:
    
        n_perms: int

        perms: None
            
        Return
        ======
    """
    rdm_a = check_rdm(rdm_a, force="vector")
    rdm_b = check_rdm(rdm_b, force="vector")

    # Score without permutation
#    true_score = spearmanr(rdm_a, rdm_b)[0]
    true_score = cross_vect_score(rdm_a, rdm_b, scoring=distance)

    # Generate random permutations of the elements
    if perms is None:
        perms = nperms_indexes(root_tri_num(rdm_a.shape[0]) + 1, n_perms)

    # Compute score distribution using permutations
    # TODO: add parrallelization by cutting in several chunks ?
    random_scores = []
    for p, perm in tqdm(enumerate(perms), total=n_perms, ascii=" -", 
                        desc="Mantel permuation test", mininterval=0.5):
        perm_v = rdm_b[perm]
        random_scores.append(cross_vect_score(rdm_a, perm_v, scoring=distance))
#        random_scores.append(spearmanr(rdm_a, perm_v)[0])
    random_scores = np.array(random_scores)

    p = np.sum(random_scores > true_score) / n_perms
    
#    if plot_f is not None:
#        fig, ax = plt.subplots()
#        sns.distplot(random_scores, ax=ax)
#        ax.set_title("Sperman ranked correlation to " + modelname + \
#                     "\n({} permutations)".format(n_perms))
#        ax.grid()
#        ax.plot([true_score, true_score], ax.get_ylim(), 'r--')
#        xmax, ymax = ax.get_xlim()[1],ax.get_ylim()[1]
#        xtext = 1.1*true_score if true_score < 0.7*xmax else 0.5*true_score
#        ax.text(
#            xtext, ymax*0.8, 
#            "True correlation: {:0.06f}\np = {:.02f}%".format(true_score, p*100),
#            fontsize=10
#        )
#        fig.savefig(plot_f)
    return p, true_score, random_scores


#Â OLD VERISON OF MANTEL TEST
def compare_rdms(brain_rdvs, model_rdvs, distance='spearmanr', n_perms=1000,
                 n_jobs=1, verbose=0):
    """
        Compute distance between RDM of each seed.

        Arguments
        -----------
        brain_rdvs:
            Reference RDM.

        model_rdvs: list of RDM as vectors
            Candidate RDMs.

        distance: str
            Any distance defined in scipy.spatial.distance.

        n_jobs: int (default: 1)
            Number of jobs that can be run in parallel.

        verbose: int (default 0)
            Verbosity

        Return
        --------
        scores:
            2D array of score obtained for each seed and each model
    """

    n_seeds = len(brain_rdvs)

    # Generate random permutations of the elements
    perms = nperms_indexes(root_tri_num(model_rdvs[0].shape[0]) + 1, n_perms)

    # Pre-processing
    if distance == "spearmanr":
        # Get rank (for repated value, their rank is averaged
        brain_rdvs = rankdata(brain_rdvs, axis=1)
        model_rdvs = rankdata(model_rdvs, axis=1)
        # Then only need to compute the pearson correlation
        distance = "pearsonr"
    elif distance == "ttest":

        # Test between values in 2 different area of the RDM
        for im, model in enumerate(model_rdvs):
            uvalues = np.unique(model)
            if len(uvalues) != 2:
                raise ValueError("Model must contain 2 different values")
            bin_model = np.zeros(model.shape, dtype=np.uint8)
            bin_model[model == uvalues[1]] = 1
            model_rdvs[im] = bin_model

    start_t = time.time()
    if distance == "ttest":
        # Compute the probabilities for each voxel in parallel
        scores = Parallel(n_jobs=n_jobs, verbose=verbose)(
            delayed(_group_iter_numerical_comparison)(
                brain_rdvs[s], model_rdvs, perms,
                verbose=max(0, verbose-1), seed=s, n_seeds=n_seeds,
                start_time=start_t)
            for s in range(n_seeds)
        )
    else:
        # Compute the probabilities for each voxel in parallel
        scores = Parallel(n_jobs=n_jobs, verbose=verbose)(
            delayed(_group_iter_compare_rdms)(
                brain_rdvs[s], model_rdvs, distance, perms,
                verbose=max(0, verbose-1), seed=s, n_seeds=n_seeds,
                start_time=start_t)
            for s in range(n_seeds)
        )

    if verbose:
        dt = time.time() - start_t
        print("Elapsed time to compare RDMs: {:.01f}s".format(dt))

    return np.array(scores)

